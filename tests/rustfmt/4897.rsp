use std::convert::TryFrom
use std::env
use std::ffi::{OsStr, OsString}
use std::io::ErrorKind
use rustc_data_structures::fx::FxHashMap
use rustc_mir::interpret::Pointer
use rustc_target::abi::{LayoutOf, Size}
impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {
}
pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {
#[allow(non_snake_case)]
fn GetCurrentDirectoryW(&mut self, size_op: &OpTy<'tcx, Tag>, buf_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, u32> {
let this = self.eval_context_mut()
this.assert_target_os("windows", "GetCurrentDirectoryW");
if IsolatedOp::Reject(reject_with) = this.machine.isolated_op {
this.reject_in_isolation("GetCurrentDirectoryW", reject_with)?;
this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;
return Ok(0);
}
let size = u64::from(this.read_scalar(size_op)?.to_u32()?)
let buf = this.read_scalar(buf_op)?.check_init()?
match env::current_dir() {
Ok(cwd) => return Ok(windows_check_buffer_size(this.write_path_to_wide_str(&cwd, buf, size)?)),
Err(e) => this.set_last_error_from_io_error(e.kind())?,
}
Ok(0)
};
}

